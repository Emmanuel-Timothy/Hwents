<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Omni-Directional Rotor Lab - Physics Edition</title>
    <style>
        :root { --neon: #00ffcc; --bg: #0a0e14; --gold: #ffaa00; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: white; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 25px; display: flex; flex-direction: column;
            justify-content: space-between; box-sizing: border-box;
        }

        .glass-panel {
            background: rgba(15, 25, 35, 0.9);
            border-left: 3px solid var(--neon);
            padding: 20px; pointer-events: auto; width: 320px;
            backdrop-filter: blur(10px); box-shadow: 0 20px 40px rgba(0,0,0,0.9);
            margin-bottom: 10px;
        }

        .title { color: var(--neon); font-weight: 800; letter-spacing: 1.5px; margin-bottom: 15px; font-size: 0.85em; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.65em; opacity: 0.5; margin-bottom: 5px; text-transform: uppercase; }
        
        input[type=range] { width: 100%; accent-color: var(--neon); cursor: pointer; }
        .val-disp { float: right; color: var(--neon); font-family: monospace; }
        .readout { font-family: 'Courier New', monospace; font-size: 1.6em; color: var(--neon); }
        .unit { font-size: 0.5em; opacity: 0.5; margin-left: 4px; }

        #math-hud { font-family: monospace; font-size: 0.75em; color: #ccc; line-height: 1.4; }
        .formula-line { color: var(--gold); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div>
        <div class="glass-panel">
            <div class="title">ENVIRONMENTAL FORCES</div>
            <div class="control-group">
                <label>Wind Speed <span id="sVal" class="val-disp">20</span></label>
                <input type="range" id="speed" min="0" max="100" value="20">
            </div>
            <div class="control-group">
                <label>Horizontal Yaw <span id="yVal" class="val-disp">0°</span></label>
                <input type="range" id="yaw" min="0" max="360" value="0">
            </div>
            <div class="control-group">
                <label>Vertical Pitch <span id="pVal" class="val-disp">0°</span></label>
                <input type="range" id="pitch" min="-90" max="90" value="0">
            </div>
            <hr style="opacity:0.1; margin: 15px 0;">
            <div class="control-group">
                <label>Blade Count <span id="bVal" class="val-disp">3</span></label>
                <input type="range" id="bladeCount" min="2" max="12" step="1" value="3">
            </div>
            <div class="control-group">
                <label>Helical Twist <span id="tVal" class="val-disp">0.7</span></label>
                <input type="range" id="twist" min="0" max="2.5" step="0.05" value="0.7">
            </div>
        </div>

        <div class="glass-panel">
            <div class="title">DYNAMIC CALCULATIONS</div>
            <div id="math-hud">Calculating vectors...</div>
        </div>
    </div>

    <div class="glass-panel">
        <div class="title">SHAFT DYNAMICS</div>
        <div class="readout" id="rpmDisp">0<span class="unit">RPM</span></div>
        <div class="readout" id="pwrDisp">0.00<span class="unit">kW</span></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Standard scene initialization
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(10, 8, 18);

    // Global illumination
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dLight.position.set(5, 10, 7);
    scene.add(dLight);
    
    // --- THE FIXED BEACON (LAMP) ---
    // PointLight with physically correct decay (distance=15, decay=2)
    const beaconLight = new THREE.PointLight(0x00ffcc, 0, 15, 2);
    scene.add(beaconLight);

    const beaconMesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 32, 32), 
        new THREE.MeshStandardMaterial({ 
            color: 0x002211, 
            emissive: 0x00ffcc, 
            emissiveIntensity: 0 
        })
    );
    beaconMesh.position.z = 1.1; // Place it just in front of the hub
    scene.add(beaconMesh);

    // Rotor group will hold the blades and hub
    let rotorGroup = new THREE.Group();
    scene.add(rotorGroup);

    // Physics State Variables
    let angVel = 0;
    const rho = 1.225; // Air density kg/m^3
    const windVec = new THREE.Vector3();

    /**
     * Reconstructs the rotor geometry based on UI sliders
     */
    function buildRotor() {
        while(rotorGroup.children.length > 0) rotorGroup.remove(rotorGroup.children[0]);
        
        const count = parseInt(document.getElementById('bladeCount').value);
        const twistFactor = parseFloat(document.getElementById('twist').value);
        const radius = 8;
        
        // Central hub geometry
        const hub = new THREE.Mesh(
            new THREE.CylinderGeometry(0.7, 0.7, 1.2, 32), 
            new THREE.MeshStandardMaterial({color: 0x111111, metalness: 1, roughness: 0.1})
        );
        hub.rotation.x = Math.PI / 2;
        rotorGroup.add(hub);

        // Procedural blade generation with helical twist
        for(let i=0; i<count; i++) {
            const bGeo = new THREE.BoxGeometry(0.6, radius, 0.08, 1, 30, 1);
            const pos = bGeo.attributes.position;
            
            for(let j=0; j<pos.count; j++) {
                let y = pos.getY(j) + (radius/2);
                let x = pos.getX(j);
                let z = pos.getZ(j);
                const t = (y/radius);
                const twist = t * twistFactor;
                const taper = 1.0 - t * 0.85;
                
                // Matrix-like rotation transformation for the twist
                pos.setXYZ(j, 
                    x * taper * Math.cos(twist) - z * Math.sin(twist), 
                    y, 
                    x * taper * Math.sin(twist) + z * Math.cos(twist)
                );
            }
            bGeo.computeVertexNormals();
            const blade = new THREE.Mesh(bGeo, new THREE.MeshStandardMaterial({color: 0xeeeeee, metalness: 0.9, roughness: 0.1, side: 2}));
            const pivot = new THREE.Group();
            pivot.rotation.z = (i * Math.PI * 2) / count;
            pivot.add(blade);
            rotorGroup.add(pivot);
        }
    }

    // Environmental Particle System (Wind visualization)
    const pCount = 2000;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(pCount * 3);
    for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5)*60;
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const windSys = new THREE.Points(pGeo, new THREE.PointsMaterial({color: 0x00ffcc, size: 0.08, transparent: true, opacity: 0.2}));
    scene.add(windSys);

    // Initial construction
    buildRotor();

    // Re-bind listeners
    document.getElementById('bladeCount').addEventListener('input', buildRotor);
    document.getElementById('twist').addEventListener('input', buildRotor);

    function animate() {
        requestAnimationFrame(animate);

        // Retrieve current UI state
        const speed = parseFloat(document.getElementById('speed').value);
        const yaw = THREE.MathUtils.degToRad(parseFloat(document.getElementById('yaw').value));
        const pitch = THREE.MathUtils.degToRad(parseFloat(document.getElementById('pitch').value));
        const count = parseInt(document.getElementById('bladeCount').value);
        const twistFactor = parseFloat(document.getElementById('twist').value);

        // Update UI displays
        document.getElementById('sVal').innerText = speed;
        document.getElementById('yVal').innerText = document.getElementById('yaw').value + "°";
        document.getElementById('pVal').innerText = document.getElementById('pitch').value + "°";
        document.getElementById('bVal').innerText = count;
        document.getElementById('tVal').innerText = twistFactor;

        // Vector Calculation: Direction of incoming wind
        windVec.set(Math.sin(yaw)*Math.cos(pitch), Math.sin(pitch), Math.cos(yaw)*Math.cos(pitch)).normalize();

        // --- ENHANCED PHYSICS ENGINE ---
        // Dot product determines how much wind actually hits the rotor face
        const alignment = Math.max(0, windVec.dot(new THREE.Vector3(0, 0, 1))); 
        const twistEff = Math.max(0, 1.0 - Math.abs(twistFactor - 0.7) * 0.5); 
        const sweptArea = Math.PI * Math.pow(8, 2);

        // 1. Wind Torque Calculation
        const torqueWind = 0.5 * rho * Math.pow(speed * 0.1, 2) * sweptArea * alignment * twistEff * 0.005;

        // 2. Drag/Friction Torque
        const dragCoeff = 0.02 + (count * 0.005);
        const torqueLoad = (angVel * dragCoeff) + (Math.pow(angVel, 2) * 0.01);

        // 3. Angular Momentum Update
        const netTorque = torqueWind - torqueLoad;
        angVel += netTorque;
        if (angVel < 0) angVel = 0;

        // Apply rotation to the 3D model
        rotorGroup.rotation.z -= angVel;

        // 4. Power Output Metrics
        const powerWatts = torqueLoad * angVel * 1000;
        const rpm = (angVel * 60) / (0.016 * 2 * Math.PI); 

        // Update DOM Readouts
        document.getElementById('rpmDisp').innerHTML = `${Math.floor(rpm)}<span class="unit">RPM</span>`;
        document.getElementById('pwrDisp').innerHTML = `${(powerWatts / 1000).toFixed(2)}<span class="unit">kW</span>`;

        // Update Math HUD
        document.getElementById('math-hud').innerHTML = `
            <div class="formula-line">τ_wind = ${torqueWind.toFixed(4)} Nm</div>
            <div class="formula-line" style="color:#ff5555">τ_load = ${torqueLoad.toFixed(4)} Nm</div>
            <hr style="opacity:0.2">
            <div>ω (Angular Vel): ${angVel.toFixed(3)} rad/s</div>
            <div style="color:var(--neon)">P = τ_load × ω</div>
            <div style="color:var(--neon)">P = ${(powerWatts).toFixed(1)} Watts</div>
        `;

        // --- AESTHETICS: THE FIX ---
        const pulse = 1.0 + Math.sin(Date.now() * 0.005) * 0.2;
        const normalizedRPM = Math.min(rpm / 600, 1.0); // Normalize for visual scaling

        // Update Beacon Light & Mesh Emissivity
        beaconLight.intensity = 60 * normalizedRPM * pulse;
        beaconLight.position.copy(beaconMesh.position);
        
        beaconMesh.material.emissiveIntensity = 4 * normalizedRPM * pulse;
        beaconMesh.scale.setScalar(1 + (normalizedRPM * 0.4) * pulse);

        // Update Wind Particle Positions
        const p = windSys.geometry.attributes.position.array;
        for(let i=0; i<pCount; i++) {
            p[i*3] += windVec.x * speed * 0.05;
            p[i*3+1] += windVec.y * speed * 0.05;
            p[i*3+2] += windVec.z * speed * 0.05;
            
            // Teleport particles back to start once they exit the bounds
            if(Math.abs(p[i*3]) > 30 || Math.abs(p[i*3+1]) > 30 || Math.abs(p[i*3+2]) > 30) {
                p[i*3] = (Math.random()-0.5)*60 - (windVec.x * 25);
                p[i*3+1] = (Math.random()-0.5)*20 - (windVec.y * 25);
                p[i*3+2] = (Math.random()-0.5)*60 - (windVec.z * 25);
            }
        }
        windSys.geometry.attributes.position.needsUpdate = true;

        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // Handle viewport changes
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
