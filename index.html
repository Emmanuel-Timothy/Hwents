<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Omni-Directional Rotor Lab - Twist & Beacon Edition</title>
    <style>
        :root { --neon: #00ffcc; --bg: #0a0e14; } /* Slightly brighter background */
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: white; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 25px; display: flex; flex-direction: column;
            justify-content: space-between; box-sizing: border-box;
        }

        .glass-panel {
            background: rgba(15, 25, 35, 0.9); /* Brighter panel */
            border-left: 3px solid var(--neon);
            padding: 20px; pointer-events: auto; width: 300px;
            backdrop-filter: blur(10px); box-shadow: 0 20px 40px rgba(0,0,0,0.9);
        }

        .title { color: var(--neon); font-weight: 800; letter-spacing: 1.5px; margin-bottom: 15px; font-size: 0.85em; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.65em; opacity: 0.5; margin-bottom: 5px; text-transform: uppercase; }
        
        input[type=range] { width: 100%; accent-color: var(--neon); cursor: pointer; }
        .val-disp { float: right; color: var(--neon); font-family: monospace; }
        .readout { font-family: 'Courier New', monospace; font-size: 1.6em; color: var(--neon); }
        .unit { font-size: 0.5em; opacity: 0.5; margin-left: 4px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="glass-panel">
        <div class="title">ENVIRONMENTAL FORCES</div>
        
        <div class="control-group">
            <label>Wind Speed <span id="sVal" class="val-disp">20</span></label>
            <input type="range" id="speed" min="0" max="100" value="20">
        </div>

        <div class="control-group">
            <label>Horizontal Yaw <span id="yVal" class="val-disp">0째</span></label>
            <input type="range" id="yaw" min="0" max="360" value="0">
        </div>

        <div class="control-group">
            <label>Vertical Pitch <span id="pVal" class="val-disp">0째</span></label>
            <input type="range" id="pitch" min="-90" max="90" value="0">
        </div>

        <hr style="opacity:0.1; margin: 15px 0;">
        
        <div class="control-group">
            <label>Blade Count <span id="bVal" class="val-disp">3</span></label>
            <input type="range" id="bladeCount" min="2" max="12" step="1" value="3">
        </div>

        <div class="control-group">
            <label>Helical Twist <span id="tVal" class="val-disp">0.7</span></label>
            <input type="range" id="twist" min="0" max="2.5" step="0.05" value="0.7">
        </div>
    </div>

    <div class="glass-panel">
        <div class="title">SHAFT DYNAMICS</div>
        <div class="readout" id="rpmDisp">0<span class="unit">RPM</span></div>
        <div class="readout" id="pwrDisp">0.00<span class="unit">kW</span></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(10, 8, 18);

    // --- Brighter Aesthetics ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // Increased from 0.1
    const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dLight.position.set(5, 10, 7);
    scene.add(dLight);
    
    // --- The Hub Beacon ---
    const beaconLight = new THREE.PointLight(0x00ffcc, 100, 50);
    scene.add(beaconLight);

    const beaconCoreGeo = new THREE.SphereGeometry(0.4, 32, 32);
    const beaconMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
    const beaconMesh = new THREE.Mesh(beaconCoreGeo, beaconMat);
    scene.add(beaconMesh);

    let rotorGroup = new THREE.Group();
    scene.add(rotorGroup);

    function buildRotor() {
        while(rotorGroup.children.length > 0) rotorGroup.remove(rotorGroup.children[0]);
        const count = parseInt(document.getElementById('bladeCount').value);
        const twistFactor = parseFloat(document.getElementById('twist').value);
        const radius = 8;
        
        const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 1.2, 32), new THREE.MeshStandardMaterial({color: 0x111111, metalness: 1, roughness: 0.1}));
        hub.rotation.x = Math.PI / 2;
        rotorGroup.add(hub);

        for(let i=0; i<count; i++) {
            const bGeo = new THREE.BoxGeometry(0.6, radius, 0.08, 1, 30, 1);
            const pos = bGeo.attributes.position;
            for(let j=0; j<pos.count; j++) {
                let y = pos.getY(j) + (radius/2);
                let x = pos.getX(j);
                let z = pos.getZ(j);
                const t = (y/radius);
                
                // Helical Twist Application
                const twist = t * twistFactor;
                const taper = 1.0 - t * 0.85;
                
                pos.setXYZ(j, x * taper * Math.cos(twist) - z * Math.sin(twist), y, x * taper * Math.sin(twist) + z * Math.cos(twist));
            }
            bGeo.computeVertexNormals();
            const blade = new THREE.Mesh(bGeo, new THREE.MeshStandardMaterial({color: 0xeeeeee, metalness: 0.9, roughness: 0.1, side: 2}));
            const pivot = new THREE.Group();
            pivot.rotation.z = (i * Math.PI * 2) / count;
            pivot.add(blade);
            rotorGroup.add(pivot);
        }
    }

    const pCount = 2000;
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(pCount * 3);
    for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5)*60;
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const windSys = new THREE.Points(pGeo, new THREE.PointsMaterial({color: 0x00ffcc, size: 0.08, transparent: true, opacity: 0.2}));
    scene.add(windSys);

    let angVel = 0;
    const windVec = new THREE.Vector3();

    function animate() {
        requestAnimationFrame(animate);
        buildRotor();

        const speed = parseFloat(document.getElementById('speed').value);
        const yaw = THREE.MathUtils.degToRad(parseFloat(document.getElementById('yaw').value));
        const pitch = THREE.MathUtils.degToRad(parseFloat(document.getElementById('pitch').value));
        const count = parseInt(document.getElementById('bladeCount').value);
        const twistFactor = parseFloat(document.getElementById('twist').value);

        document.getElementById('sVal').innerText = speed;
        document.getElementById('yVal').innerText = document.getElementById('yaw').value + "째";
        document.getElementById('pVal').innerText = document.getElementById('pitch').value + "째";
        document.getElementById('bVal').innerText = count;
        document.getElementById('tVal').innerText = twistFactor;

        windVec.set(Math.sin(yaw)*Math.cos(pitch), Math.sin(pitch), Math.cos(yaw)*Math.cos(pitch)).normalize();

        // Physics: Torque depends on alignment (Dot Product) and Twist Efficiency
        const dot = windVec.dot(new THREE.Vector3(0, 0, 1));
        const twistEfficiency = Math.max(0, 1.0 - Math.abs(twistFactor - 0.7) * 0.5);
        const torque = speed * 0.00015 * dot * twistEfficiency;
        const drag = angVel * (0.02 + count * 0.003);
        
        angVel += (torque - drag);
        rotorGroup.rotation.z -= angVel;

        const rpm = (angVel * 60) / (0.016 * 2 * Math.PI);
        const power = Math.abs(0.5 * 1.225 * Math.PI * 64 * Math.pow(speed, 3) * 0.35 * dot * twistEfficiency) / 1000;
        
        document.getElementById('rpmDisp').innerHTML = `${Math.floor(rpm)}<span class="unit">RPM</span>`;
        document.getElementById('pwrDisp').innerHTML = `${power.toFixed(2)}<span class="unit">kW</span>`;

        const pulse = 1.0 + Math.sin(Date.now() * 0.005) * 0.2;
        beaconLight.intensity = Math.min(rpm * 2, 500) * pulse;
        beaconMesh.scale.setScalar(1 + (rpm / 500) * pulse);
        
        beaconMesh.position.set(0,0,1.2);
        beaconLight.position.set(0,0,1.5);

        const p = windSys.geometry.attributes.position.array;
        for(let i=0; i<pCount; i++) {
            p[i*3] += windVec.x * speed * 0.05;
            p[i*3+1] += windVec.y * speed * 0.05;
            p[i*3+2] += windVec.z * speed * 0.05;
            if(Math.abs(p[i*3]) > 30 || Math.abs(p[i*3+1]) > 30 || Math.abs(p[i*3+2]) > 30) {
                p[i*3] = (Math.random()-0.5)*60 - (windVec.x * 25);
                p[i*3+1] = (Math.random()-0.5)*20 - (windVec.y * 25);
                p[i*3+2] = (Math.random()-0.5)*60 - (windVec.z * 25);
            }
        }
        windSys.geometry.attributes.position.needsUpdate = true;

        controls.update();
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
